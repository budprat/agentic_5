# type: ignore
import json
import os
import sqlite3
import traceback
import asyncio

from pathlib import Path

import google.generativeai as genai
import numpy as np
import pandas as pd
import requests

from a2a_mcp.common.utils import init_api_key
from mcp.server.fastmcp import FastMCP
from mcp.server.fastmcp.utilities.logging import get_logger
from a2a_mcp.mcp.remote_mcp_connector import RemoteMCPRegistry


logger = get_logger(__name__)
AGENT_CARDS_DIR = 'agent_cards'
MODEL = 'models/embedding-001'
SQLLITE_DB = 'travel_agency.db'
PLACES_API_URL = 'https://places.googleapis.com/v1/places:searchText'


def generate_embeddings(text):
    """Generates embeddings for the given text using Google Generative AI.

    Args:
        text: The input string for which to generate embeddings.

    Returns:
        A list of embeddings representing the input text.
    """
    return genai.embed_content(
        model=MODEL,
        content=text,
        task_type='retrieval_document',
    )['embedding']


def load_agent_cards():
    """Loads agent card data from JSON files within a specified directory.

    Returns:
        A list containing JSON data from an agent card file found in the specified directory.
        Returns an empty list if the directory is empty, contains no '.json' files,
        or if all '.json' files encounter errors during processing.
    """
    card_uris = []
    agent_cards = []
    dir_path = Path(AGENT_CARDS_DIR)
    if not dir_path.is_dir():
        logger.error(
            f'Agent cards directory not found or is not a directory: {AGENT_CARDS_DIR}'
        )
        return agent_cards

    logger.info(f'Loading agent cards from card repo: {AGENT_CARDS_DIR}')

    for filename in os.listdir(AGENT_CARDS_DIR):
        if filename.lower().endswith('.json'):
            file_path = dir_path / filename

            if file_path.is_file():
                logger.info(f'Reading file: {filename}')
                try:
                    with file_path.open('r', encoding='utf-8') as f:
                        data = json.load(f)
                        card_uris.append(
                            f'resource://agent_cards/{Path(filename).stem}'
                        )
                        agent_cards.append(data)
                except json.JSONDecodeError as jde:
                    logger.error(f'JSON Decoder Error {jde}')
                except OSError as e:
                    logger.error(f'Error reading file {filename}: {e}.')
                except Exception as e:
                    logger.error(
                        f'An unexpected error occurred processing {filename}: {e}',
                        exc_info=True,
                    )
    logger.info(
        f'Finished loading agent cards. Found {len(agent_cards)} cards.'
    )
    return card_uris, agent_cards


def build_agent_card_embeddings() -> pd.DataFrame:
    """Loads agent cards, generates embeddings for them, and returns a DataFrame.

    Returns:
        Optional[pd.DataFrame]: A Pandas DataFrame containing the original
        'agent_card' data and their corresponding 'Embeddings'. Returns None
        if no agent cards were loaded initially or if an exception occurred
        during the embedding generation process.
    """
    card_uris, agent_cards = load_agent_cards()
    logger.info('Generating Embeddings for agent cards')
    try:
        if agent_cards:
            df = pd.DataFrame(
                {'card_uri': card_uris, 'agent_card': agent_cards}
            )
            df['card_embeddings'] = df.apply(
                lambda row: generate_embeddings(json.dumps(row['agent_card'])),
                axis=1,
            )
            return df
        logger.info('Done generating embeddings for agent cards')
    except Exception as e:
        logger.error(f'An unexpected error occurred : {e}.', exc_info=True)
        return None


def serve(host, port, transport):  # noqa: PLR0915
    """Initializes and runs the Agent Cards MCP server.

    Args:
        host: The hostname or IP address to bind the server to.
        port: The port number to bind the server to.
        transport: The transport mechanism for the MCP server (e.g., 'stdio', 'sse').

    Raises:
        ValueError: If the 'GOOGLE_API_KEY' environment variable is not set.
    """
    init_api_key()
    logger.info('Starting Agent Cards MCP Server')
    mcp = FastMCP('agent-cards', host=host, port=port)

    df = build_agent_card_embeddings()
    
    # Initialize remote MCP registry
    remote_registry = RemoteMCPRegistry()
    logger.info('Initialized Remote MCP Registry')

    @mcp.tool(
        name='find_agent',
        description='Finds the most relevant agent card based on a natural language query string.',
    )
    def find_agent(query: str) -> str:
        """Finds the most relevant agent card based on a query string.

        This function takes a user query, typically a natural language question or a task generated by an agent,
        generates its embedding, and compares it against the
        pre-computed embeddings of the loaded agent cards. It uses the dot
        product to measure similarity and identifies the agent card with the
        highest similarity score.

        Args:
            query: The natural language query string used to search for a
                   relevant agent.

        Returns:
            The json representing the agent card deemed most relevant
            to the input query based on embedding similarity.
        """
        query_embedding = genai.embed_content(
            model=MODEL, content=query, task_type='retrieval_query'
        )
        dot_products = np.dot(
            np.stack(df['card_embeddings']), query_embedding['embedding']
        )
        best_match_index = np.argmax(dot_products)
        logger.debug(
            f'Found best match at index {best_match_index} with score {dot_products[best_match_index]}'
        )
        return df.iloc[best_match_index]['agent_card']

    @mcp.tool()
    def query_places_data(query: str):
        """Query Google Places."""
        logger.info(f'Search for places : {query}')
        api_key = os.getenv('GOOGLE_PLACES_API_KEY')
        if not api_key:
            logger.info('GOOGLE_PLACES_API_KEY is not set')
            return {'places': []}

        headers = {
            'X-Goog-Api-Key': api_key,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress',
            'Content-Type': 'application/json',
        }
        payload = {
            'textQuery': query,
            'languageCode': 'en',
            'maxResultCount': 10,
        }

        try:
            response = requests.post(
                PLACES_API_URL, headers=headers, json=payload
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            logger.info(f'HTTP error occurred: {http_err}')
            logger.info(f'Response content: {response.text}')
        except requests.exceptions.ConnectionError as conn_err:
            logger.info(f'Connection error occurred: {conn_err}')
        except requests.exceptions.Timeout as timeout_err:
            logger.info(f'Timeout error occurred: {timeout_err}')
        except requests.exceptions.RequestException as req_err:
            logger.info(
                f'An unexpected error occurred with the request: {req_err}'
            )
        except json.JSONDecodeError:
            logger.info(
                f'Failed to decode JSON response. Raw response: {response.text}'
            )

        return {'places': []}

    @mcp.tool()
    def query_travel_data(query: str) -> dict:
        """
        "name": "query_travel_data",
        "description": "Retrieves the most up-to-date, ariline, hotel and car rental availability. Helps with the booking.
        This tool should be used when a user asks for the airline ticket booking, hotel or accommodation booking, or car rental reservations.",
        "parameters": {
            "type": "object",
            "properties": {
            "query": {
                "type": "string",
                "description": "A SQL to run against the travel database."
            }
            },
            "required": ["query"]
        }
        """
        # The above is to influence gemini to pickup the tool.
        logger.info(f'Query sqllite : {query}')

        if not query or not query.strip().upper().startswith('SELECT'):
            raise ValueError(f'In correct query {query}')

        try:
            with sqlite3.connect(SQLLITE_DB) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()
                cursor.execute(query)
                rows = cursor.fetchall()
                result = {'results': [dict(row) for row in rows]}
                return json.dumps(result)
        except Exception as e:
            logger.error(f'Exception running query {e}')
            logger.error(traceback.format_exc())
            if 'no such column' in e:
                return {
                    'error': f'Please check your query, {e}. Use the table schema to regenerate the query'
                }
            return {'error': {e}}

    @mcp.resource('resource://agent_cards/list', mime_type='application/json')
    def get_agent_cards() -> dict:
        """Retrieves all loaded agent cards as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/list'.

        Returns:
            A json / dictionary structured as {'agent_cards': [...]}, where the value is a
            list containing all the loaded agent card dictionaries. Returns
            {'agent_cards': []} if the data cannot be retrieved.
        """
        resources = {}
        logger.info('Starting read resources')
        resources['agent_cards'] = df['card_uri'].to_list()
        return resources

    @mcp.resource(
        'resource://agent_cards/{card_name}', mime_type='application/json'
    )
    def get_agent_card(card_name: str) -> dict:
        """Retrieves an agent card as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/{card_name}'.

        Returns:
            A json / dictionary
        """
        resources = {}
        logger.info(
            f'Starting read resource resource://agent_cards/{card_name}'
        )
        resources['agent_card'] = (
            df.loc[
                df['card_uri'] == f'resource://agent_cards/{card_name}',
                'agent_card',
            ]
        ).to_list()

        return resources

    @mcp.tool(
        name='call_remote_tool',
        description='Call a tool on a remote MCP server',
    )
    async def call_remote_tool(
        server_name: str,
        tool_name: str,
        arguments: dict
    ) -> dict:
        """Call a tool on a specific remote MCP server.
        
        Args:
            server_name: Name of the remote MCP server
            tool_name: Name of the tool to call
            arguments: Dictionary of arguments to pass to the tool
            
        Returns:
            The result from the remote tool call
        """
        try:
            result = await remote_registry.connector.call_remote_tool(
                server_name, tool_name, arguments
            )
            return {'success': True, 'result': result}
        except Exception as e:
            logger.error(f'Error calling remote tool: {e}')
            return {'success': False, 'error': str(e)}

    @mcp.tool(
        name='list_remote_servers',
        description='List all configured remote MCP servers',
    )
    def list_remote_servers() -> dict:
        """List all configured remote MCP servers.
        
        Returns:
            Dictionary containing information about all remote servers
        """
        servers = []
        for name, server in remote_registry.connector.servers.items():
            servers.append({
                'name': name,
                'transport': server.transport,
                'description': server.description,
                'url': server.url if server.transport == 'sse' else None,
                'command': server.command if server.transport == 'stdio' else None
            })
        return {'servers': servers}

    @mcp.tool(
        name='discover_remote_tools',
        description='Discover all tools available from remote MCP servers',
    )
    async def discover_remote_tools(server_name: str = None) -> dict:
        """Discover tools available from remote MCP servers.
        
        Args:
            server_name: Optional specific server name to query
            
        Returns:
            Dictionary of available tools grouped by server
        """
        try:
            if server_name:
                tools = remote_registry.connector.get_available_tools(server_name)
            else:
                tools = await remote_registry.get_all_available_tools()
            return {'success': True, 'tools': tools}
        except Exception as e:
            logger.error(f'Error discovering remote tools: {e}')
            return {'success': False, 'error': str(e)}

    @mcp.tool(
        name='register_remote_server',
        description='Register a new remote MCP server',
    )
    def register_remote_server(
        name: str,
        transport: str,
        url: str = None,
        command: str = None,
        args: list = None,
        env: dict = None,
        description: str = None
    ) -> dict:
        """Register a new remote MCP server.
        
        Args:
            name: Unique name for the server
            transport: Transport type ('sse' or 'stdio')
            url: URL for SSE transport
            command: Command for stdio transport
            args: Command arguments for stdio transport
            env: Environment variables
            description: Server description
            
        Returns:
            Success status
        """
        try:
            from a2a_mcp.mcp.remote_mcp_connector import RemoteMCPServer
            
            server = RemoteMCPServer(
                name=name,
                transport=transport,
                url=url,
                command=command,
                args=args,
                env=env,
                description=description
            )
            remote_registry.connector.register_server(server)
            return {'success': True, 'message': f'Server {name} registered successfully'}
        except Exception as e:
            logger.error(f'Error registering remote server: {e}')
            return {'success': False, 'error': str(e)}

    # Research-specific MCP tools for Nexus system
    @mcp.tool()
    def query_academic_databases(query: str, databases: list = None) -> dict:
        """
        Query multiple academic databases for research synthesis.
        Supports DOAJ, PubMed, ArXiv, JSTOR, Web of Science, etc.
        """
        logger.info(f'Query academic databases: {query}')
        
        if not query or not query.strip():
            raise ValueError(f'Query cannot be empty: {query}')
        
        try:
            # Default databases if none specified
            if not databases:
                databases = ['pubmed', 'arxiv', 'doaj']
            
            # Simulated academic database query results
            # In production, this would connect to real academic APIs
            results = []
            for db in databases:
                db_results = simulate_academic_query(db, query)
                results.extend(db_results)
            
            return {
                'results': results, 
                'status': 'success', 
                'total_papers': len(results),
                'databases_queried': databases
            }
        except Exception as e:
            logger.error(f'Academic database query error: {e}')
            return {'error': str(e)}

    @mcp.tool()
    def analyze_cross_domain_patterns(research_data: list, domains: list) -> dict:
        """Identify patterns and connections across disciplinary boundaries."""
        logger.info(f'Cross-domain pattern analysis for {len(domains)} domains')
        
        try:
            patterns = []
            causal_links = []
            anomalies = []
            
            # Simulate cross-domain analysis
            # In production, this would use advanced ML algorithms
            for i, domain_a in enumerate(domains):
                for domain_b in domains[i+1:]:
                    connection = {
                        'domains': [domain_a, domain_b],
                        'connection_strength': 0.7,  # Simulated score
                        'type': 'methodological_similarity',
                        'description': f'Similar research methodologies between {domain_a} and {domain_b}'
                    }
                    patterns.append(connection)
            
            # Calculate synthesis quality score
            synthesis_score = len(patterns) * 0.8  # Simulated calculation
            
            return {
                'patterns': patterns,
                'causal_links': causal_links, 
                'anomalies': anomalies,
                'synthesis_score': synthesis_score,
                'domains_analyzed': domains
            }
        except Exception as e:
            logger.error(f'Cross-domain analysis error: {e}')
            return {'error': str(e)}

    @mcp.tool()
    def generate_knowledge_graph(entities: list, relationships: list) -> dict:
        """Generate knowledge graph for research synthesis visualization."""
        logger.info(f'Generating knowledge graph with {len(entities)} entities')
        
        try:
            # Simulate knowledge graph generation
            # In production, this would integrate with Neo4j or similar
            graph_id = f"research_graph_{len(entities)}_{len(relationships)}"
            
            return {
                'graph_id': graph_id,
                'entities_created': len(entities),
                'relationships_created': len(relationships),
                'status': 'success',
                'visualization_url': f'/graphs/{graph_id}'
            }
        except Exception as e:
            logger.error(f'Knowledge graph generation error: {e}')
            return {'error': str(e)}

    @mcp.tool()
    def detect_research_bias(papers: list, methodologies: list) -> dict:
        """Detect methodological bias and conflicts across research papers."""
        logger.info(f'Bias detection for {len(papers)} papers')
        
        try:
            bias_indicators = []
            methodology_conflicts = []
            quality_scores = []
            
            # Simulate bias detection analysis
            for i, paper in enumerate(papers):
                bias_score = {
                    'paper_id': i,
                    'title': paper.get('title', f'Paper {i}'),
                    'bias_score': 0.3,  # Simulated score (0-1, lower is better)
                    'bias_types': ['selection_bias', 'publication_bias'],
                    'methodology_quality': 0.8  # Simulated quality score
                }
                bias_indicators.append(bias_score)
                quality_scores.append(0.8)
            
            overall_reliability = sum(quality_scores) / len(quality_scores) if quality_scores else 0
            
            return {
                'bias_indicators': bias_indicators,
                'methodology_conflicts': methodology_conflicts,
                'quality_scores': quality_scores,
                'overall_reliability': overall_reliability
            }
        except Exception as e:
            logger.error(f'Bias detection error: {e}')
            return {'error': str(e)}

    @mcp.tool()
    def query_research_data(query: str) -> dict:
        """
        Query research databases for academic papers and citations.
        This tool should be used for academic research synthesis and analysis.
        """
        logger.info(f'Query research data: {query}')

        if not query or not query.strip().upper().startswith('SELECT'):
            raise ValueError(f'Incorrect query {query}. Must be a valid SQL SELECT statement.')

        try:
            # In production, this would connect to a research database
            # For now, simulate research data response
            result = {
                'results': [
                    {
                        'title': 'Sample Research Paper',
                        'authors': ['Dr. Smith', 'Dr. Jones'],
                        'journal': 'Nature',
                        'year': 2023,
                        'citations': 45,
                        'doi': '10.1038/sample.2023.001',
                        'domain': 'life_sciences'
                    }
                ],
                'total_results': 1,
                'query_time': '0.2s'
            }
            return json.dumps(result)
        except Exception as e:
            logger.error(f'Exception running research query {e}')
            logger.error(traceback.format_exc())
            return {'error': str(e)}

    @mcp.tool()
    def synthesize_research_findings(findings: list, synthesis_type: str = 'comprehensive') -> dict:
        """Synthesize research findings across multiple domains."""
        logger.info(f'Synthesizing {len(findings)} research findings')
        
        try:
            synthesis = {
                'synthesis_type': synthesis_type,
                'key_themes': [],
                'contradictions': [],
                'research_gaps': [],
                'novel_insights': [],
                'confidence_score': 0.85
            }
            
            # Simulate synthesis analysis
            for finding in findings:
                theme = {
                    'theme': f"Theme from {finding.get('domain', 'unknown')}",
                    'evidence_strength': 'moderate',
                    'supporting_papers': 3
                }
                synthesis['key_themes'].append(theme)
            
            return synthesis
        except Exception as e:
            logger.error(f'Research synthesis error: {e}')
            return {'error': str(e)}

def simulate_academic_query(database: str, query: str) -> list:
    """Simulate academic database query results."""
    # In production, this would make real API calls to academic databases
    base_results = [
        {
            'title': f'Research Paper from {database.upper()}',
            'authors': ['Dr. Example', 'Prof. Sample'],
            'abstract': f'This paper discusses {query} from the perspective of {database}.',
            'year': 2023,
            'citations': 25,
            'doi': f'10.{database}/sample.2023.001',
            'database': database,
            'url': f'https://{database}.org/paper/sample'
        }
    ]
    return base_results

    logger.info(
        f'Agent cards MCP Server at {host}:{port} and transport {transport}'
    )
    mcp.run(transport=transport)